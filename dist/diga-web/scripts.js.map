{"version":3,"sources":["webpack:///node_modules/direction-reveal/scripts/direction-reveal.js"],"names":[],"mappings":"AAAA;AACA;;AAEA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,KAAK;;AAEN;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,cAAc,IAAI,MAAM,GAAG,gBAAgB;AAC5E;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;;AAGP;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;;AAET;AACA;;AAEA,wEAAwE,cAAc;AACtF;;AAEA;AACA;AACA,SAAS;;AAET;;AAEA,KAAK;AACL;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA,wCAAwC,cAAc;AACtD,sDAAsD,cAAc,UAAU,cAAc;AAC5F;AACA,KAAK;;AAEL;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA","file":"scripts.js","sourcesContent":["/**\n  Direction aware content reveals.\n\n  @param {Object} object - Container for all options.\n  @param {string} selector - Container element selector.\n  @param {string} itemSelector - Item element selector.\n  @param {string} animationName - Animation CSS class.\n  @param {bollean} enableTouch  - Adds touch event to show content on first click then follow link on the second click.\n  @param {integer} touchThreshold - Touch length must be less than this to trigger reveal which prevents the event triggering if user is scrolling.\n*/\n\n\nconst DirectionReveal = function ({\n  selector: selector = '.direction-reveal',\n  itemSelector: itemSelector = '.direction-reveal__card',\n  animationName: animationName = 'swing',\n  enableTouch: enableTouch = true,\n  touchThreshold: touchThreshold = 250\n} = {}) {\n\n  const containers = document.querySelectorAll(selector);\n  let touchStart;\n\n\n  const getDirection = function (e, item) {\n    // Width and height of current item\n    let w = item.offsetWidth;\n    let h = item.offsetHeight;\n    let position = getPosition(item);\n\n    // Calculate the x/y value of the pointer entering/exiting, relative to the center of the item.\n    let x = (e.pageX - position.x - (w / 2) * (w > h ? (h / w) : 1));\n    let y = (e.pageY - position.y - (h / 2) * (h > w ? (w / h) : 1));\n\n    // Calculate the angle the pointer entered/exited and convert to clockwise format (top/right/bottom/left = 0/1/2/3).  See https://stackoverflow.com/a/3647634 for a full explanation.\n    let d = Math.round(Math.atan2(y, x) / 1.57079633 + 5) % 4;\n\n    // console.table([x, y, w, h, e.pageX, e.pageY, item.offsetLeft, item.offsetTop, position.x, position.y]);\n\n    return d;\n  };\n\n\n  // https://www.kirupa.com/html5/get_element_position_using_javascript.htm\n  const getPosition = function (el) {\n    let xPos = 0;\n    let yPos = 0;\n\n    while (el) {\n      xPos += (el.offsetLeft + el.clientLeft);\n      yPos += (el.offsetTop + el.clientTop);\n\n      el = el.offsetParent;\n    }\n    return {\n      x: xPos,\n      y: yPos\n    };\n  }\n\n\n  const translateDirection = switchcase({\n    0: 'top',\n    1: 'right',\n    2: 'bottom',\n    3: 'left'\n  })('top');\n\n\n  const addClass = function (e, state) {\n    let currentItem = e.currentTarget;\n    let direction = getDirection(e, currentItem);\n    let directionString = translateDirection(direction);\n\n    // Remove current animation classes and add new ones e.g. swap --in for --out.\n    let currentCssClasses = currentItem.className.split(' ');\n    let filteredCssClasses = currentCssClasses.filter((cssClass) => (!cssClass.startsWith(animationName))).join(' ');\n    currentItem.className = filteredCssClasses;\n    currentItem.classList.add(`${animationName}--${state}-${directionString}`);\n  };\n\n\n  const bindEvents = function (containerItem) {\n    const items = containerItem.querySelectorAll(itemSelector);\n\n    items.forEach((item) => {\n\n      addEventListenerMulti(item, ['mouseenter', 'focus'], (e) => {\n        addClass(e, 'in');\n      });\n\n      addEventListenerMulti(item, ['mouseleave', 'blur'], (e) => {\n        addClass(e, 'out');\n      });\n\n\n      if (enableTouch) {\n\n        item.addEventListener('touchstart', (e) => {\n          touchStart = +new Date;\n        }, {\n          passive: true\n        });\n\n        item.addEventListener('touchend', (e) => {\n          let touchTime = +new Date - touchStart;\n\n          if (touchTime < touchThreshold && !item.className.includes(`${animationName}--in`)) {\n            e.preventDefault();\n\n            resetVisible(e, items, addClass(e, 'in'));\n          }\n        });\n\n      }\n\n    });\n  };\n\n  const addEventListenerMulti = function (element, events, fn) {\n    events.forEach((e) => element.addEventListener(e, fn));\n  }\n\n\n  const resetVisible = function (e, items, callback) {\n\n    items.forEach((item) => {\n      let currentCssClasses = item.className;\n\n      if (currentCssClasses.includes(`${animationName}--in`) && item !== e.currentTarget) {\n        item.className = currentCssClasses.replace(`${animationName}--in`, `${animationName}--out`);\n      }\n    });\n\n    callback;\n  };\n\n\n  const init = function () {\n\n    if (containers.length) {\n      containers.forEach((containerItem) => {\n        bindEvents(containerItem);\n      });\n    } else {\n      return;\n    }\n\n  };\n\n  // Init is called by default\n  init();\n\n\n  // Reveal API\n  return {\n    init\n  };\n};\n"],"sourceRoot":""}